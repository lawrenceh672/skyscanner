import pandas as pd
import sqlite3
import numpy as np
import os
from Tracked import Tracked
#from BBVideo import VideoFileMetaInformation
import datetime
from PIL import Image
from io import BytesIO
import cv2

from DBThread import DB

class bbdb(DB):
	def __init__(self,dbFileName):
		self.db = sqlite3.connect(dbFileName)
		self.dbFileName = dbFileName
		self.commands = []

	def commitAll(self):
		for c in self.commands:
			print(c)
	def wipeDB(self):
		with current_app.open_resource('createdb.sql') as f:
			self.db.executescript(f.read().decode('utf8'))

	def closeAndCommit(self):
		self.db.commit() #Commit all transactions and close the database for other threads
		self.db.close()
						
	def getFiles(self):
		sql_query = 'SELECT * FROM files;'
		df = pd.read_sql_query(sql_query, self.db)
		return df

	def getTotalFrameCount(self,path):
		sql_query = "SELECT FRAME_COUNT FROM CAMERA_SESSION WHERE PATH  LIKE '{}%';".format(path)
		df = pd.read_sql_query(sql_query, self.db)
		ret = df['FRAME_COUNT'][0]
		return int(ret)

	def getOriginalDimensions(self, path):
		sql_query = "SELECT MAX(W),MAX(H) FROM FILES WHERE PATH LIKE '{}%';".format(path)
		df = pd.read_sql_query(sql_query, self.db)
		try:
			return (int(df['MAX(W)']),int(df['MAX(H)']))
		except Exception:
			print("Missing file '{}".format(path))
			return (0,0)

	def getSessionRecordtime(self, path):
		sql_query = "SELECT START_TIME FROM CAMERA_SESSION WHERE PATH LIKE '{}%';".format(path)
		df = pd.read_sql_query(sql_query, self.db)
		ret = int(df['START_TIME'])
		return ret

	
	def getMotionProcessTime(self, path):
		sql_query = "SELECT MIN(MOTION_RAN) FROM FILES WHERE PATH LIKE '{}%';".format(path)
		df = pd.read_sql_query(sql_query, self.db)
		try:
			t=df['MIN(MOTION_RAN)'][0]
			return int(t)
		except Exception:
			return None

	def motionPassed(self, path):
		#Check if the file has has been motion passed at least, if so itll have resize_w value, otherwise its zero
		sql_query = """	
		SELECT RESIZED_W 
		FROM FILES 
		WHERE PATH = \'%s\';
		""" % (path)
		ret = self.db.execute(sql_query)
		ret = ret.fetchone()[0] #if its zero then 
		if ret == 0:
			return False
		return True

	def addFile(self, path):
		#Check if the file is in the db
		last_run = self.getMotionProcessTime(path)
		if last_run is None: #File isnt in the db already so we'll need to add it
			vfmi = VideoFileMetaInformation(path)
			if vfmi is None:
				print("Cant read " + path)
				return False
			curr_dt = datetime.datetime.now()
			timeStamp = int(round(curr_dt.timestamp()))
			sql = "INSERT INTO FILES VALUES(?,?,?,?,?,?,?,?);"
			data_tuple = (path, 0 ,vfmi.frame_count, vfmi.width, vfmi.height, 0 ,0, timeStamp)
			self.db.execute(sql, data_tuple)
			self.db.commit()
		

	def updateFileProcessParameters(self, path, resized_w,resized_h):
		curr_dt = datetime.datetime.now()
		timeStamp = int(round(curr_dt.timestamp()))
		sql = "UPDATE FILES SET RESIZED_W = '{}',RESIZED_H = '{}',MOTION_RAN = '{}' WHERE PATH = '{}'".format(resized_w,resized_h,timeStamp,path)
		self.db.execute(sql)
		self.db.commit()
		return False #Not done yet

	def resetFile(self, path): #Remove all tracking objects and high res files generated by motion passes
		sql = "DELETE FROM TRACKED_OBJECTS WHERE PATH LIKE '{}%';".format(path)
		self.db.execute(sql)
		self.db.commit()
		#Now get all the high res images stored from this file, delete the files from the HD and remove the database entries
		sql = "SELECT IMAGE_FILENAME FROM HIGHRESIMAGES WHERE PATH LIKE '{}%';".format(path)
		cur = self.db.execute(sql)
		row = cur.fetchone()
		while row is not None:
			f = row[0]
			try:
				os.remove(f)
			except OSError as e:
				print("Error: %s : %s" % (f, e.strerror))
			row = cur.fetchone()
		sql = "DELETE FROM HIGHRESIMAGES WHERE PATH LIKE '{}%';".format(path)
		self.db.execute(sql)
		self.db.commit()


	def convertToBinaryData(self, filename):
		# Convert digital data to binary format
		with open(filename, 'rb') as file:
			binaryData = file.read()
		return binaryData		

	def addTrackedObject(self, path, to):
		#add to or update the existing tracked object
		sql = "INSERT INTO TRACKED_OBJECTS(ID,PATH,FRAME_START,FRAME_END,XYWH_TRACK) VALUES(?,?,?,?,?)"
		xywh = ""
		for t in to.xywh_track: #Represent it as x,y,w,h; repeated for all tracks
			xywh = xywh + str(t[0]) + "," + str(t[1]) + "," + str(t[2]) + "," + str(t[3]) + ";"
		#Slice off the last semi colon to help the split function not output a blank at the end
		xywh = xywh[0:len(xywh) - 1]
		data_tuple =(to.ID, path,
					to.frame_start,to.frame_end,
					xywh)
		self.db.execute(sql, data_tuple)
		self.db.commit()

	def getTrackedObjects(self, path):
		#Return a list of Tracked_objects from the database.
		sql_query = "SELECT * FROM TRACKED_OBJECTS WHERE PATH LIKE '{}%' ORDER BY ID;".format(path)
		df = pd.read_sql_query(sql_query, self.db)
		ret = []

		for index, row in df.iterrows():
			xywh = str(row['XYWH_TRACK'])
			xywh = xywh.split(";")
			#Tracked object from the database
			frame_start = row['FRAME_START']

			#Now go through each tuple in string format
			xywh_track = []
			for i in xywh:
				t = str(i).split(",") #Recreate the tracking square from the DB and put it back into python object memory
				r = (int(t[0]),int(t[1]),int(t[2]),int(t[3]))
				xywh_track.append(r)

			x = Tracked(frame_start) #Construct the tracked object from the dataframe
			#None for the image and the initial xywh tracking square. the tracking path will be copied in all at once from above
			x.xywh_track = xywh_track
			x.frame_end = int(row['FRAME_END']) #We already know how this ends, so just set the end frame number
			x.ID = int(row['ID']) #Dont want the tracked object to autoincrement
			ret.append(x)
		return ret

	def getTrackedObject(self,path,id):
		#Return the one tracked object
		sql_query = 'SELECT * FROM TRACKED_OBJECTS WHERE PATH = \'%s\' AND ID = \'%d\';' % (path, id)
		df = pd.read_sql_query(sql_query, self.db)
		#rebuild the xywh track path
		xywh = str(df['XYWH_TRACK'][0])
		xywh = xywh.split(";")
		#Now go through each tuple in string format
		xywh_track = []
		for i in xywh:
			t = str(i).split(",")
			r = (int(t[0]),int(t[1]),int(t[2]),int(t[3]))
			xywh_track.append(r)

		#Tracked object from the database
		x = Tracked(r,df['FRAME_START'][0],None) #Construct the tracked object from the dataframe
		#None for the image and the initial xywh tracking square. the tracking path will be copied in all at once from above
		x.xywh_track = xywh_track
		x.frame_end = int(df['FRAME_END'][0]) #We already know how this ends, so just set the end frame number
		x.ID = int(df['ID'])
		return x

	def getTrackedObjectCount(self,path):
		sql_query = 'SELECT COUNT(*) FROM TRACKED_OBJECTS WHERE PATH =\'%s\';' % path
		ret = self.db.execute(sql_query)
		ret = ret.fetchone()[0] #Get the count from the select count SQL

		return int(ret)

	def getRecords(self,path):
		sql_query = 'SELECT * FROM TRACKED_OBJECTS WHERE PATH = \'%s\' ORDER BY ID;' % (path)
		df = pd.read_sql_query(sql_query, self.db)
		df['TIME'] = df['FRAME_END'] - df['FRAME_START']
		df['AREA'] = df['W'] * df['H']
		return df

	def getUserClassifications(self,path):
		#Retrieve all the user classified images for this video file
		sql = "SELECT * FROM CLASSIFIER_SAMPLES WHERE PATH LIKE '{}%'".format(path)
		df = pd.read_sql_query(sql, self.db)
		return df

	def updateClassification(self,path,TrackedObjectID,className):
		#Update the classification column in trackedObjects with className
		sql_query = 'UPDATE TRACKED_OBJECTS SET CLASSIFICATION = \'%s\' WHERE ID = \'%s\' AND PATH = \'%s\';' % (className,TrackedObjectID,path)
		self.db.execute(sql_query)
		self.db.commit()
		#Check if the user classified name is in the classification database
		#If its not, add an entry

	def addHighResImage(self, path, frameIndex, saveFile, fullPath):
		#Add a record showing a high res save path for this file at this frame index
		sql = "INSERT INTO HIGHRESIMAGES(PATH, FRAME_INDEX, IMAGE_FILENAME) VALUES(?,?,?);"
		data_tuple =(path, frameIndex, saveFile)
		self.db.execute(sql, data_tuple)
		self.db.commit()

	def getHighResImages(self, path, toID):
		#Get a list of paths to the high res images existing between the start and the end of the tracking object ID
		#Format [(frame index, image path)....]
		to = self.getTrackedObject(path, toID)
		start = to.frame_start
		end = to.frame_end
		sql = 'SELECT * FROM HIGHRESIMAGES WHERE PATH = \'%s\' AND FRAME_INDEX BETWEEN \'%s\' AND \'%s\';' % (path, start, end)
		df = pd.read_sql_query(sql, self.db)
		ret = df[['FRAME_INDEX', 'IMAGE_FILENAME']]
		ret2 = []
		for index, row in ret.iterrows():
			val = (int(row['FRAME_INDEX']), str(row['IMAGE_FILENAME']))
			ret2.append(val)
		return ret2

	def getAllHRImages(self, path):
		sql = "SELECT * FROM HIGHRESIMAGES WHERE PATH LIKE '{}%';".format(path)
		df = pd.read_sql_query(sql, self.db)
		ret = {} #{FrameIndex: HR image path}
		for index, row in df.iterrows():
			frameIndex = int(row['FRAME_INDEX'])
			imagePath = str(row['IMAGE_FILENAME'])
			ret.update({frameIndex: imagePath})
		return ret

	def getMotionPassWH(self, path):
		sql = "SELECT MAX(RESIZED_W), MAX(RESIZED_H) FROM FILES WHERE PATH LIKE '{}%'".format(path)
		cur = self.db.execute(sql)
		ret = cur.fetchone()
		(w, h) = (ret[0],ret[1])
		return (w,h)
	


	def fileInDB(self, path):
		sql = 'SELECT COUNT(*) FROM FILES WHERE PATH = \'%s\';' % (path)
		cur = self.db.execute(sql)
		ret = cur.fetchone()
		count = ret[0]
		if count == 0:
			return False
		return True

	def runScript(self, script):
		with open(script, 'r') as sql_file:
			sql_script = sql_file.read()

		cursor = self.db.cursor()
		print("Running Script {}: ".format(sql_script))
		cursor.executescript(sql_script)
		self.db.commit()

	def addCameraFeed(self, camera):
		#Send the name of the camera and the path its storing files
		#Add a row 
		sql = "INSERT INTO CAMERA_SESSION(CAMERA_NAME, PATH, FRAMESPERFILE, FRAME_COUNT, START_TIME, ISRUNNING) VALUES(?,?,?,?,?, 1);"
		data_tuple =(camera.name, camera.fullPath, camera.framesPerFile, camera.frame_count, camera.startTime)
		self.db.execute(sql, data_tuple)
		self.db.commit()

	def updateCameraSession(self, camera):
		sql_query = "UPDATE CAMERA_SESSION SET FRAME_COUNT = {}, ISRUNNING = {} WHERE CAMERA_NAME = '{}' AND START_TIME = '{}';".format(camera.frame_count, camera.isRunning, camera.name, camera.startTime)
		self.db.execute(sql_query)
		self.db.commit()

	def getListofCameras(self): #Returns a list of cameras from the database using camera objects
		sql_query = 'SELECT * FROM CAMERAS'
		df = pd.read_sql_query(sql_query, self.db)
		return df

	def getSessionFiles(self, path):
		#Search FILES where the path is in the full path of the video file
		#d:\upload\1.mp4 == d:\upload\
		sql = "SELECT PATH FROM FILES WHERE PATH LIKE '{}%'".format(path)
		df = pd.read_sql_query(sql, self.db)
		ret = df['PATH'].tolist()
		return ret

	def getFrame(self, path, frameIndex):
		hr = self.getAllHRImages(self.path) #A list of tuples [(frameindex, filename),...]
		for key, value in hr.items():
			if(key == frameIndex): #If the frameindex is already stored in the database return the pre-existing image
				frame = cv2.imread(value)
				return (key, frame) #The full filename of the HR frame image
		#If nothing matched then we must create the HR image from the video file, and note in the database
		self.fvs = FileVideoStream(self.path).start()
		ret = self.fvs.more()
		frame = self.fvs.read() #Read in the next frame image
		frameCount = 0

		while ret is not False and frame is not None:
			if frameIndex == frameCount:
				print("Returning frame " +  str(frameCount))
				saveFile = self.hrSavePath + self.filename + "frame" + str(self.frame_count) + ".jpg"
				cv2.imwrite(saveFile, frame) #save it to disk
				self.db.addHighResImage(self.path, frameIndex, saveFile)
			else:
				frameCount = frameCount + 1
		self.fvs.stop()
		return (self.path, frame)

	def deleteSession(self, path):
		sql = "DELETE FROM CAMERA_SESSION WHERE PATH LIKE '{}%'".format(path)
		self.db.execute(sql)
		self.db.commit() #Delete from the camera session table
		#Now delete the video files too
		sql = "SELECT PATH FROM FILES WHERE PATH LIKE '{}%';".format(path)
		cur = self.db.execute(sql)
		row = cur.fetchone()
		while row is not None:
			f = row[0]
			try:
				os.remove(f)
			except OSError as e:
				print("Error: %s : %s" % (f, e.strerror))
			row = cur.fetchone()
		#Now remove the whole directory as well TODO
		self.resetFile(path) #And now reset the Tracked Objects and Photo files

	def getSessions(self):
		sql = "SELECT * FROM CAMERA_SESSION"
		df = pd.read_sql_query(sql, self.db)
		return df

	def getFrameImageFileName(self, path, frameIndex): #Return the filename of the video file for a frame in a camera session
		#And the files frame range (path, (frame_start, frame_end))
		sql = "SELECT PATH, FRAME_COUNT FROM FILES WHERE PATH LIKE '{}%'".format(path)
		df = pd.read_sql_query(sql, self.db)
		#Now loop through file's file count until it exceeds the frameindex, then return that filename
		frameTotal = 0
		for row in df.itertuples():
			frameIncrement = row.FRAME_COUNT
			frameTotal += frameIncrement
			if frameTotal > frameIndex:
				range = (frameTotal - frameIncrement, frameTotal)
				return (row.PATH, range)
		range = (frameTotal - frameIncrement, frameTotal)
		return (row.PATH, range)

			#{frame: {((x1,y1),(x2,y2)): "name"}
	def getClassifierSampleCoords(self, path):
		sql = "SELECT * FROM CLASSIFIER_SAMPLES WHERE PATH LIKE '{}%'".format(path)
		df = pd.read_sql_query(sql, self.db)
		ret = {} #The returned dictionary
		#Now go through the data frame and create the dictionary for easier python processing
		#{frame: {((x1,y1),(x2,y2)): "name"}
		for row in df.itertuples():
			x1 = row.X
			y1 = row.Y
			x2 = x1 +row.W
			y2 = y1 + row.H

			if row.FRAME_INDEX not in ret: #This frame isnt in the index
				inner = {}
				inner.update({((x1,y1),(x2,y2)): row.CLASSIFICATION_NAME})
				ret.update({row.FRAME_INDEX: inner})
			else: #The frame already has a classifier identified on it, add another to this frames information
				inner = ret[row.FRAME_INDEX] #get the existing dict of tracking squares in this frame
				inner.update({((x1,y1),(x2,y2)): row.CLASSIFICATION_NAME})
				ret.update({row.FRAME_INDEX : inner})
		return ret

	def addClassification(self,path,frameIndex,x,y,w,h,classification_name,image):
		#Add a user supplied classification to the database, its identifying numbers and image sample
		sql = "INSERT INTO CLASSIFIER_SAMPLES(PATH, FRAME_INDEX, X, Y, W, H, CLASSIFICATION_NAME, IMAGE) VALUES(?,?,?,?,?,?,?,?);"
		#Change the incoming numpy array to a byte array for the sql BLOB type
		im_bytes = image.tobytes()
		data_tuple =(path, frameIndex, x, y, w, h, classification_name, im_bytes)
		self.db.execute(sql, data_tuple)
		#Now check if this classification sample is a new classification and needs adding, or is adding to an existing classificaiton
		sql = "SELECT * FROM CLASSIFICATIONS WHERE NAME = '{}'".format(classification_name)
		df = pd.read_sql_query(sql, self.db)
		length = len(df)
		if length == 0:
			sql = "INSERT INTO CLASSIFICATIONS(NAME, CLASSIFIER, LAST_RUN, NUM_SAMPLES, SAMPLES_DEPTH) VALUES (?,?,?,?,?);"
			data_tuple = (classification_name, b'0x0', 0, 1, len(image))
			self.db.execute(sql, data_tuple)
		self.db.commit()

	def deleteClassificationSample(self, path, name, image):
		sql = "DELETE FROM CLASSIFIER_SAMPLES WHERE IMAGE = {}".format(image)

	def getClassificationSampleImages(self, name):
		sql = "SELECT * FROM CLASSIFIER_SAMPLES WHERE CLASSIFICATION_NAME = '{}'".format(name)
		df = pd.read_sql_query(sql, self.db)
		ret = {} #{(frame_index,x,y,w,h,session): image}
		for row in df.itertuples():
			img = row.IMAGE
			x=row.X
			y=row.Y
			w=row.W
			h=row.H
			name = row.CLASSIFICATION_NAME
			frame_index = row.FRAME_INDEX
			session = row.PATH
			image = np.frombuffer(img, dtype = np.uint8) #RGB images uncompressed raw bytes from numpy array
			image.shape = (h,w,3)
			#Change it to a PIL image for further processing
			pilImage = Image.fromarray(image)
			key = (session,frame_index,x,y,w,h)
			ret.update({key: pilImage})
		return ret

	def getClassificationImagesBySession(self, path):
		sql = "SELECT * FROM CLASSIFIER_SAMPLES WHERE PATH LIKE '{}%'".format(path)
		df = pd.read_sql_query(sql, self.db)
		ret = {} #{name: [image array 1, image array 2,...]}
		for row in df.itertuples():
			img = row.IMAGE
			w=row.W
			h=row.H
			name = row.CLASSIFICATION_NAME
			x = np.frombuffer(img, dtype = np.uint8) #RGB images uncompressed raw bytes from numpy array
			x.shape = (h,w,3)
			if name not in ret: #Start building the image list
				inner = [x]
				ret.update({name: inner})
			else:
				inner = ret[name] #Get the image list
				inner.append(x)
				ret.update({name:inner})
		return ret

	def getClassifierSampleImages(self, name):
		#Returns a list of the sample images gathered for this classifier
		sql = "SELECT * FROM CLASSIFIER_SAMPLES WHERE CLASSIFICATION_NAME = '{}'".format(name)
		df = pd.read_sql_query(sql, self.db)
		ret = []
		for row in df.itertuples():
			img = row.IMAGE
			w=row.W
			h=row.H
			name = row.CLASSIFICATION_NAME
			x = np.frombuffer(img, dtype = np.uint8) #RGB images uncompressed raw bytes from numpy array
			x.shape = (h,w,3)
			img = Image.fromarray(x) #Convert to PIL
			#Add the image to return list
			ret.append(img)
		return ret

	def getClassifier(self, name):
		sql = "SELECT * FROM CLASSIFICATIONS WHERE NAME = '{}'".format(name)
		df = pd.read_sql_query(sql, self.db)
		return df

	def getNewestSessionPath(self): #Return the path of the newest Camera session
		sql = "SELECT *,MAX(START_TIME) FROM CAMERA_SESSION;"
		df = pd.read_sql_query(sql, self.db)
		return df['PATH'][0]

	def getAllClassificationNames(self):
		#Return a list of all names
		sql = "SELECT NAME FROM CLASSIFICATIONS"
		df = self.executeSQL(sql)
		ret = df['NAME'].to_list()
		return ret

		###Time to stop repeating the df data frame read, need one function to call, one line that will execute it
		#dataframe returns for selects, sql.execute for inserts and updates and deletes

	def executeSQL(self, sql, data = None): #Will need to specify data or it will default to select
		self.commands.append((sql,data)) #keep the list for records, or queuing into a thread
		#Get the operation type from the first word of the sql query
		type = sql.split(" ")[0]

		if type == "SELECT":
			df = pd.read_sql_query(sql, self.db)
			return df
		if type == "UPDATE" or type == "DELETE" or type == "INSERT":
			self.db.execute(sql, data)
			self.db.commit()
